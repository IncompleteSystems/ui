import { Meta } from '@storybook/blocks';

<Meta title='Internals/Component Behaviors' />

# Default Component Behaviors

The library is designed around the idea of composing behaviors together create feature-rich components.

The *magic* ðŸª„ of our engine is that we proxy to a component template that wraps `React.forwardRef`, so you don't have to.

We also provide the following built-in behaviors:

- **ElementTag**: Allows you to change the HTML tag of a component, which provides the `as` and `asChild` props.
- **ClassName**: Expands the supported data types on the `className` prop of a component, also provides *Template Literals (template strings)* support.
- **Properties**: Allows you to intercept the value of any property passed to a component.

You can easily add features to your ui library by creating your own `UIComponentFeature`.

# Custom Component Behaviors

**Component behaviors provide a way to customize components that are generated by our library.**

`UIComponentFeature` is a function that takes a `Component` && `UILibraryConfig` and returns a `UIComponentHook` which is a React Hook that will be used by the component.

```tsx
type UIComponentFeature<CustomProps extends {} = {}, CustomConfig extends {} = {}> = (component: string | ComponentType<CustomProps>, config: UILibraryConfig<CustomConfig>) => UIComponentHook<CustomProps>;
```

Each `UIComponentHook` is responsible for encapsulating behavior and returning a set of properties that will be passed to the component.

```tsx
type UIComponentHook<CustomProps extends {}> = (props: PropsWithChildren<CustomProps>, ref: ForwardedRef<unknown>) => PropsWithChildren<CustomProps>
```

We can rebuild our **Properties** behavior using `UIComponentFeature` in only a few lines of code.

```tsx
// Our component feature is a function that takes a component and a library config
const propertiesFeature: UIComponentFeature<{}, { props?: PropertyProcessors }> = (_component, config) => {

  // The component feature returns a hook that takes props and a ref
  return (props, ref) => {

    // If no prop handlers are defined, we return the original props
    if (!config.props) return props;

    // The hook returns the processed props which are passed to the component
    return Object.fromEntries(

      // We map over the props and return the processed value
      Object.entries(props).map(([key, value]) => {

        // We get the prop processor for the current prop
        const propProcessor = config.props?.[key];

        // If a prop processor is defined, we run it and return the processed value
        // Otherwise, we return the original value
        return [key, propProcessor ? propProcessor(value, props, ref) : value];
      })
    );
  }
}
```

Finally, we reduce all the `UIComponentHook` properties internally and pass them to the component. In doing so behaviours are able to override each other and are applied in the order they are defined in our `UILibraryConfig.features` array.
